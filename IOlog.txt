a# IOlog - Interaction and Operation Log
Last Updated: [Current Date]

## Agent Registry
### Level the Laborer
- Role: Primary Development Assistant
- Purpose: Assist with code development, debugging, and implementation tasks
- Specialization: Code analysis, implementation, and problem-solving
- Status: Active

### Archy the Sleuth
- Role: Bug and Build Problem Investigator
- Purpose: Investigate and resolve build issues, track down bugs, and ensure system stability
- Specialization: Build system analysis, bug tracking, and system diagnostics
- Status: Active

### Anthrax the Bug Destroyer
- Role: Bug Extermination Specialist
- Purpose: Hunt and destroy bugs from the bottom to the top of the stack
- Specialization: Deep stack analysis, bug eradication, and system hardening
- Status: Active

## Project Goals
1. Create a custom C++ engine targeting AMD hardware with:
   - Vulkan for graphics rendering (cross-platform, low-level, AMD-optimized)
   - HIP (Heterogeneous-compute Interface for Portability) for GPU compute
2. Implementation Requirements:
   - Set up graphics and GPU programming pipeline (AMD-focused)
   - Implement Vulkan for graphics first
   - Add HIP for compute after Vulkan setup
   - Use CMake build system
3. Development Environment:
   - Set up Docker with X11 forwarding for graphics output
   - Enable GPU passthrough for Docker
   - Maintain backup summary of all user inputs
4. Documentation:
   - Document build and run instructions
   - Add HIP/Vulkan examples
   - Maintain comprehensive documentation

## 3D Game of Life Implementation
### Core Features
1. 3D Cellular Automata
   - 3D grid system (e.g., 64x64x64 or 128x128x128)
   - Cell states: Alive/Dead
   - 3D neighborhood rules (Moore neighborhood in 3D)
   - Efficient state updates using compute shaders

2. Visualization
   - 3D cube rendering for cells
   - Camera controls (orbit, pan, zoom)
   - Cell coloring based on age/state
   - Optional wireframe mode
   - Performance-optimized instanced rendering

3. User Interface
   - Play/Pause simulation
   - Speed control
   - Grid size adjustment
   - Pattern loading/saving
   - Camera controls
   - Cell placement/removal
   - Statistics display (population, generation count)

4. Performance Optimizations
   - GPU-accelerated state updates using HIP
   - Efficient memory management for large grids
   - Instanced rendering for cell visualization
   - Compute shader-based state calculations
   - Double buffering for state updates

### Technical Requirements
1. Memory Management
   - Efficient grid storage using device-local memory
   - Double buffering for state updates
   - Memory pooling for cell instances
   - Sparse resource management for large grids

2. Compute Pipeline
   - HIP kernels for state calculations
   - Compute shader integration
   - Efficient synchronization between compute and graphics
   - Parallel processing for large grids

3. Graphics Pipeline
   - Instanced rendering for cells
   - Efficient vertex/index buffer management
   - Dynamic pipeline state management
   - Optimized shader compilation

4. Performance Targets
   - Support for grids up to 256x256x256
   - 60+ FPS with 128x128x128 grid
   - Efficient memory usage (< 1GB for large grids)
   - Smooth camera controls

### Development Phases
1. Phase 1: Core Engine
   - [x] Basic Vulkan setup
   - [x] Command buffer optimization
   - [x] Device feature optimization
   - [ ] Memory management system
   - [ ] Compute pipeline setup
   - [ ] Basic rendering pipeline

2. Phase 2: Grid System
   - [ ] 3D grid data structure
   - [ ] State management system
   - [ ] Compute shader implementation
   - [ ] Memory optimization
   - [ ] State update pipeline

3. Phase 3: Visualization
   - [ ] Cell rendering system
   - [ ] Camera controls
   - [ ] Instanced rendering
   - [ ] Basic UI elements
   - [ ] Performance optimization

4. Phase 4: User Interface
   - [ ] Control system
   - [ ] Pattern management
   - [ ] Statistics display
   - [ ] Settings interface
   - [ ] Performance monitoring

## TODO List
### Vulkan Pipeline Setup
1. âœ… Basic Vulkan instance creation
2. âœ… Physical device selection
3. âœ… Logical device creation
4. âœ… Command pool setup
5. âœ… Queue Family Selection
   - âœ… Implement queue family index finding
   - âœ… Add support for multiple queue families
   - âœ… Handle queue priorities
6. âœ… Window System Integration
   - âœ… Add GLFW dependency
   - âœ… Create window surface
   - âœ… Handle window events
7. â¬œ Swap Chain Setup
   - Query swap chain support
   - Create swap chain
   - Create image views
8. â¬œ Graphics Pipeline
   - Create render pass
   - Create shader modules
   - Create pipeline layout
   - Create graphics pipeline
9. â¬œ Framebuffers
   - Create framebuffers
   - Handle window resizing
10. â¬œ Command Buffers
    - Create command buffers
    - Record drawing commands
11. â¬œ Synchronization
    - Add semaphores
    - Add fences
    - Implement frame rendering

### HIP Integration (Future)
1. â¬œ HIP Setup
2. â¬œ Compute Pipeline
3. â¬œ Memory Management
4. â¬œ Compute Shaders

## Interaction Log
### Session 1
- Date: [Current Date]
- Agent: Level the Laborer
- Action: Created IOlog.txt file
- Purpose: Establish tracking system for agent interactions and project goals
- Status: Completed

### Session 2
- Date: [Current Date]
- Agent: Level the Laborer
- Action: Implemented basic Vulkan engine structure
- Purpose: Set up foundation for Vulkan graphics pipeline
- Details:
  * Created VulkanEngine class with core functionality
  * Implemented instance creation and device selection
  * Added command pool and queue setup
  * Prepared for graphics pipeline implementation
- Status: In Progress

### Session 3
- Date: [Current Date]
- Agent: Level the Laborer
- Action: Created detailed TODO list and progress tracking
- Purpose: Organize development tasks and track progress
- Status: Completed

### Session 4
- Date: [Current Date]
- Agent: Level the Laborer
- Action: Implemented queue family selection
- Purpose: Enable proper queue management for graphics and presentation
- Details:
  * Added QueueFamilyIndices structure
  * Implemented findQueueFamilies method
  * Updated device creation to use selected queue families
  * Added support for multiple queue families
  * Updated command pool creation to use graphics queue family
- Status: Completed

### Session 5
- Date: [Current Date]
- Agent: Level the Laborer
- Action: Implemented window system integration
- Purpose: Add window management and surface creation
- Details:
  * Added GLFW as a dependency
  * Created window management system
  * Implemented surface creation
  * Added window resize callback
  * Updated queue family selection to consider surface support
  * Added main loop with event polling
- Status: Completed

### Session 6
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Fixed Docker build issues with HIP packages
- Purpose: Resolve package installation errors in Docker build
- Details:
  * Added AMD ROCm repository configuration
  * Updated HIP package names to match ROCm repository
  * Added necessary repository setup packages
  * Fixed package installation sequence
- Status: Completed

### Session 7
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Improved Docker build process
- Purpose: Enhance reliability of Docker container builds
- Details:
  * Updated Dockerfile with dynamic Ubuntu version detection
  * Added lsb-release package for better repository configuration
  * Created build_docker.bat script for easier container management
  * Improved cleanup process for container builds
- Status: Completed

### Session 8
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Simplified Docker configuration for initial testing
- Purpose: Get basic graphics working before adding HIP support
- Details:
  * Removed HIP packages temporarily
  * Added complete X11 and graphics packages
  * Focused on getting basic graphics display working
  * Added virtual framebuffer support
- Status: In Progress

[2024-03-21 15:30:00] Performance Optimization Session
Actions:
1. Implemented separate command pools for graphics and compute operations
2. Added double buffering for command buffers
3. Enabled performance-critical device features
4. Added compute queue support for HIP operations
5. Optimized command buffer recording

Status:
- [x] Command pool and buffer optimization
- [x] Device feature optimization
- [x] Compute queue implementation
- [x] Command buffer recording infrastructure
- [ ] Memory management optimization
- [ ] Pipeline state optimization
- [ ] Shader optimization
- [ ] Synchronization optimization

Next Steps:
1. Implement memory management optimizations:
   - Device-local memory allocation
   - Memory pooling
   - Buffer streaming
2. Optimize pipeline state:
   - Pipeline cache
   - Dynamic state
   - Pipeline derivatives
3. Implement shader optimizations:
   - Shader specialization
   - Shader module caching
   - Compute shader integration
4. Add synchronization optimizations:
   - Timeline semaphores
   - Pipeline barriers
   - Queue synchronization

Notes:
- Current implementation focuses on command buffer and device feature optimization
- Next phase will focus on memory management and pipeline optimization
- Consider implementing Vulkan validation layers for debugging
- Plan to add performance monitoring and profiling tools

### Session 9
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Attempted Vulkan SDK installation and verification
- Purpose: Set up Vulkan development environment for Windows
- Details:
  * Found existing Vulkan SDK at C:\VulkanSDK\1.4.313.0
  * Attempted to verify installation with vulkaninfo
  * Discovered incomplete/corrupted installation
  * Initiated reinstallation process
  * Downloaded fresh Vulkan SDK installer
  * Provided instructions for clean installation
  * Successfully reinstalled Vulkan SDK
- Status: Completed
- Next Steps:
  1. Set up X11 server (VcXsrv)
  2. Configure Docker GPU support
  3. Run Vulkan engine with proper GPU passthrough

### Session 19
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Verified Vulkan SDK installation
- Purpose: Confirm successful Vulkan SDK installation
- Details:
  * Vulkan SDK successfully reinstalled
  * Ready to proceed with X11 and Docker GPU setup
- Status: Completed
- Next Steps:
  1. Install and configure VcXsrv for X11 forwarding
  2. Set up Docker GPU passthrough
  3. Test Vulkan engine with GPU support

### Session 10
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Made HIP optional in build system
- Purpose: Allow building without HIP for initial testing
- Details:
  * Modified CMakeLists.txt to make HIP optional
  * Added conditional HIP linking
  * Added WITH_HIP compile definition
  * Updated build configuration for better flexibility
- Status: Completed

### Session 11
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Added X11 development packages
- Purpose: Fix GLFW build dependencies
- Details:
  * Added libx11-dev for X11 core development
  * Added libxrandr-dev for X11 RandR extension
  * Added libxinerama-dev for X11 Xinerama extension
  * Added libxcursor-dev for X11 cursor support
  * Added libxi-dev for X11 input extension
- Status: Completed

### Session 12
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Added GLM library dependency
- Purpose: Support 3D mathematics in the engine
- Details:
  * Added libglm-dev package
  * Added support for vector and matrix operations
  * Prepared for 3D transformations
  * Enabled mathematical operations needed for 3D Game of Life
- Status: Completed

### Session 13
- Date: [Current Date]
- Agent: Anthrax the Bug Destroyer
- Action: Fixed dependency and include issues
- Purpose: Resolve linter errors and improve build system
- Details:
  * Added GLM dependency via FetchContent in CMakeLists.txt
  * Updated Vulkan SDK installation in Dockerfile
  * Improved include directory handling
  * Added proper linking for GLM library
  * Removed redundant Vulkan packages in favor of official SDK
- Status: Completed

### Session 14
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Added basic shaders for testing
- Purpose: Enable basic rendering for configuration testing
- Details:
  * Created basic.vert for vertex processing
  * Created basic.frag for fragment processing
  * Added support for position and color attributes
  * Prepared for basic triangle rendering test
- Status: Completed

### Session 15
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Added OpenGL development packages
- Purpose: Fix GLFW build dependencies
- Details:
  * Added libgl1-mesa-dev for OpenGL headers
  * Added libglu1-mesa-dev for GLU headers
  * Fixed missing GL/gl.h dependency
  * Ensured proper OpenGL development environment
- Status: Completed

### Session 16
- Date: [Current Date]
- Agent: Anthrax the Bug Destroyer
- Action: Fixed critical bugs in VulkanEngine
- Purpose: Resolve memory leaks and initialization issues
- Details:
  * Fixed static device access method
  * Added missing shader module cleanup
  * Implemented descriptor set layout creation
  * Added proper static instance management
  * Fixed initialization order in constructor
  * Added proper cleanup for all Vulkan resources
- Status: Completed

### Session 17
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Fixed VulkanEngine static access issues
- Purpose: Resolve compilation errors and improve instance management
- Details:
  * Fixed static device access method
  * Renamed instance to vkInstance for clarity
  * Added proper static instance management
  * Updated all instance references
  * Improved error handling in static methods
- Status: Completed

### Session 18
- Date: [Current Date]
- Agent: Archy the Sleuth
- Action: Verified Docker build and configuration
- Purpose: Ensure the engine builds and runs in a containerized environment
- Details:
  * Fixed static device access in VulkanEngine
  * Ensured all dependencies are installed (OpenGL, Vulkan, X11, GLM)
  * Improved Dockerfile and docker-compose.yml for build and runtime
  * Confirmed shaders and executable are built in the correct location
  * Validated build process and container startup
- Status: Completed

### Session 20
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Verified Docker GPU passthrough for AMD Radeon RX 6700 XT
- Purpose: Ensure Docker can access the AMD GPU
- Details:
  * Attempted to run ROCm container for GPU verification
  * Discovered missing /dev/kfd device
  * Checked Docker Desktop GPU configuration
  * Found that Docker Desktop on Windows primarily supports NVIDIA GPUs through WSL2
  * Decided on hybrid approach for optimal development and performance
- Status: In Progress
- Next Steps:
  1. Development Environment (Docker):
     - Keep Docker for building and development
     - Maintain containerized build system
     - Use for CI/CD and team consistency
  2. Testing/Running Environment (Native Windows):
     - Build and run game directly on Windows
     - Use Windows AMD drivers for optimal performance
     - Direct hardware access for testing
  3. Implementation Plan:
     a. Keep Docker build system as is
     b. Add Windows-specific build target
     c. Create Windows build script
     d. Set up development workflow:
        - Build in Docker
        - Copy artifacts to Windows
        - Run and test natively
  4. Required Setup:
     - Verify Windows AMD drivers
     - Install Visual Studio Build Tools
     - Set up CMake for Windows
     - Create Windows build configuration

### Session 21
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Implementing hybrid development approach
- Purpose: Set up optimal development and testing environment
- Details:
  * Confirmed hybrid approach:
    - Docker for building/development
    - Native Windows for running/testing
  * Verified current state:
    - Docker build system is working
    - Need to set up Windows build target
    - Need to verify Windows Vulkan setup
- Status: In Progress
- Next Steps:
  1. Windows Environment Setup:
     a. Verify AMD drivers are installed
     b. Install Vulkan SDK for Windows
     c. Test Vulkan support
  2. Build System Updates:
     a. Add Windows-specific CMake configuration
     b. Create Windows build script
     c. Set up artifact copying from Docker to Windows
  3. Development Workflow:
     a. Build in Docker
     b. Copy executables to Windows
     c. Run and test natively
  4. Documentation:
     a. Update build instructions
     b. Document Windows setup
     c. Add testing workflow guide

### Session 22
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Created Windows build configuration
- Purpose: Set up Windows build system for native testing
- Details:
  * Created Windows build script (scripts/build_windows.bat):
    - Checks for Visual Studio installation
    - Verifies Vulkan SDK setup
    - Configures CMake for Windows
    - Builds project with Visual Studio
    - Copies shaders to output directory
  * Created Docker-to-Windows copy script (scripts/copy_to_windows.bat):
    - Copies Docker build artifacts to Windows
    - Sets up proper directory structure
    - Handles shader files
- Status: Completed
- Next Steps:
  1. Test Windows build script
  2. Verify Docker-to-Windows copy process
  3. Test native Windows execution
  4. Update documentation with new workflow

### Session: VulkanEngine.h Header Repair
- Date: [2024-03-19]
- Action: Reviewed and repaired VulkanEngine.h
- Details:
  * Removed non-static overloads of findMemoryType and getDevice, keeping only static versions.
  * Ensured all members are declared only once and cleaned up any duplicate or misplaced declarations.
  * Synchronized header with implementation to resolve overload, redefinition, and build errors.
- Next Steps:
  * Rebuild the project to verify that errors are resolved.

### Session 23
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Successfully set up Vulkan rendering environment
- Purpose: Create foundation for 3D Game of Life simulation
- Details:
  * Resolved compiler errors in VulkanEngine.h
  * Fixed shader compilation and loading
  * Added vertex data to render a triangle
  * Updated shaders to handle all vertex attributes
  * Set dynamic viewport and scissor states
  * Verified proper rendering with triangle display
- Status: Completed
- Next Steps:
  1. Implement 3D Game of Life using existing shaders:
     - game_of_life_3d.comp
     - population_reduction.comp
  2. Create grid for cellular automaton
  3. Set up compute pipeline for simulation
  4. Add user interaction controls
  5. Optimize for AMD Radeon RX 6700 XT

### Session 24
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Planning 3D Game of Life implementation
- Purpose: Define architecture for cellular automaton simulation
- Details:
  * Game of Life is a cellular automaton based on simple rules
  * 3D version will use a cubic grid of cells
  * Each cell's state evolves based on neighbor count
  * Will use compute shaders for parallel processing on GPU
  * Will utilize existing files:
    - Grid3D class for managing the 3D cellular grid
    - game_of_life_3d.comp shader for simulation logic
    - population_reduction.comp for statistics
- Status: In Progress
- Next Steps:
  1. Instantiate Grid3D class
  2. Initialize the grid with random pattern or preset
  3. Set up rendering of 3D grid using points or cubes
  4. Implement time-step controls for simulation
  5. Add UI for statistics and control

### Session 25
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Implementing 3D Game of Life
- Purpose: Create interactive cellular automaton simulation
- Details:
  * Modified main.cpp to set up Grid3D simulation:
    - Created 32x32x32 grid
    - Initialized with random patterns
    - Added interface for starting, pausing, and stepping
    - Added keyboard controls for simulation interaction
  * Added Grid3D.cpp to the build system
  * Integrated Conway's Game of Life rules in 3D space:
    - Cells survive with 4-6 neighbors
    - Dead cells are born with exactly 4 neighbors
    - Uses 26 neighbors in 3D space (surrounding cells)
  * Setup compute shader pipeline for efficient GPU simulation
  * Added UI controls and statistics display
- Status: In Progress
- Next Steps:
  1. Implement 3D visualization of the grid
  2. Add color coding based on cell age
  3. Create camera controls for viewing the simulation
  4. Add preset patterns and saving/loading functionality
  5. Optimize performance for large grid sizes

### Session 26
- Date: [2024-03-19]
- Agent: Level the Laborer
- Action: Completed functional Vulkan triangle renderer
- Purpose: Get basic rendering working for future 3D Game of Life
- Details:
  * Simplified the project to focus on core Vulkan rendering
  * Removed Grid3D, Camera, RayCaster, and UI components temporarily
  * Implemented a clean, working triangle renderer
  * Set up frame rate limiting for smoother animation
  * Added keyboard controls and proper cleanup
  * Fixed issues with shader loading and vertex buffer creation
- Status: Completed
- Next Steps:
  1. Incrementally add Game of Life components
  2. Fix the Grid3D class to work with VulkanEngine
  3. Add proper visualization for 3D cellular automaton
  4. Implement camera controls for viewing the simulation
  5. Complete the user interface

## Level the Laborer's Recent Work
- Created IOlog.txt and established agent/project tracking
- Implemented the basic Vulkan engine structure:
  * Created VulkanEngine class with core functionality
  * Implemented Vulkan instance creation and device selection
  * Added command pool and queue setup
  * Prepared for graphics pipeline implementation
- Set up CMake build system and project structure
- Added GLFW integration for windowing
- Added shader and pipeline support
- Maintained a TODO list and tracked project progress
- Provided a foundation for HIP integration (future work)

## Notes
- This log will be updated with each significant interaction
- New agents will be registered in the Agent Registry section
- Project goals will be tracked and updated as they evolve
- Each session will be logged with date, agent, action, and status
- TODO list will be updated as tasks are completed
- Status indicators: âœ… Completed, ðŸ”„ In Progress, â¬œ Not Started

2025-05-17 18:31:41 - Build attempt with original Dockerfile and CMakeLists.txt. Error: Executable not found at /workspace/build/engine.
2025-05-17 18:33:49 - Rebuilt Docker image after updating CMakeLists.txt and Dockerfile to use 'vulkan-engine' as the executable name. Error persisted: Executable not found at /workspace/build/vulkan-engine.
2025-05-17 18:35:32 - Rebuilt Docker image with diagnostic step to list build directory contents. Output truncated, unable to verify executable presence.
2025-05-17 18:38:12 - Rebuilt Docker image with verbose build output and additional diagnostic steps to list build and shaders directories. Awaiting results to confirm executable presence and diagnose further.
2025-05-17 18:45:23 - Build successful, but encountered Vulkan validation errors:
  - Validation layers requested but not available
  - Multiple "Copying old device 0 into new device 0" warnings
  - Invalid device error in vkDeviceWaitIdle
  - Next steps: Fix Vulkan device initialization and validation layer setup

## Refactoring Plan: Modular Vulkan Engine (YYYY-MM-DD)

**Goal:** Refactor the monolithic `VulkanEngine` class into a component-based architecture to improve maintainability, testability, and collaboration.

**Overall Strategy:**
- Gradually extract responsibilities from `VulkanEngine` into new, focused manager classes.
- `VulkanEngine` will become a coordinator, owning instances of these managers.
- Update dependencies and call sites as functionality is moved.
- Ensure the application remains functional (or at least buildable) after each major step.
- Update/create unit tests for new/refactored components.

---

**Phase 1: Core Vulkan Context & Device Management**
*   **Objective:** Isolate Vulkan instance, physical/logical device, and queue management.
1.  **Create `QueueFamilyIndices.h` (if not already separate)**
    *   [ ] Define the `QueueFamilyIndices` struct.
2.  **Create `DeviceManager.h` and `DeviceManager.cpp`**
    *   [ ] Members: `VkPhysicalDevice physicalDevice`, `VkDevice device`, `QueueFamilyIndices queueFamilyIndices`, `VkQueue graphicsQueue`, `VkQueue presentQueue`, `VkQueue computeQueue`. (Potentially references to `VulkanContext` or `VkInstance`/`VkSurfaceKHR` for queries).
    *   [ ] Methods:
        *   `DeviceManager(VkInstance instance, VkSurfaceKHR surface)` constructor.
        *   `pickPhysicalDevice()`
        *   `isDeviceSuitable(VkPhysicalDevice physicalDevice) const`
        *   `findQueueFamilies(VkPhysicalDevice physicalDevice) const`
        *   `checkDeviceExtensionSupport(VkPhysicalDevice physicalDevice) const`
        *   `createLogicalDevice(const std::vector<const char*>& validationLayers, const VkPhysicalDeviceFeatures& enabledFeatures, const std::vector<const char*>& deviceExtensions)`
        *   `cleanup()`
        *   Getters for `VkPhysicalDevice`, `VkDevice`, `QueueFamilyIndices`, and queues.
3.  **Create `VulkanContext.h` and `VulkanContext.cpp`**
    *   [ ] Members: `VkInstance vkInstance`, `VkDebugUtilsMessengerEXT debugMessenger`, `std::unique_ptr<DeviceManager> deviceManager`.
    *   [ ] Methods:
        *   `VulkanContext(GLFWwindow* window)` (or takes surface directly)
        *   `init(const std::vector<const char*>& validationLayers, const std::vector<const char*>& requiredExtensions)` (Handles instance creation, debug messenger setup, surface creation - surface creation might move to WindowManager later).
        *   `initDeviceManager(const VkPhysicalDeviceFeatures& enabledFeatures, const std::vector<const char*>& deviceExtensions)`
        *   `cleanup()`
        *   Getters for `VkInstance`, `VkDevice` (via `deviceManager`), `VkPhysicalDevice` (via `deviceManager`), queues (via `deviceManager`), `VkSurfaceKHR` (if owned here).
4.  **Refactor `VulkanEngine` to use `VulkanContext`**
    *   [ ] `VulkanEngine` holds `std::unique_ptr<VulkanContext>`.
    *   [ ] Delegate `createInstance`, `setupDebugMessenger`, `pickPhysicalDevice`, `createLogicalDevice` calls to `VulkanContext` and its `DeviceManager`.
    *   [ ] Update `VulkanEngine` methods that use `vkInstance`, `physicalDevice`, `device`, `queues` to get them from `VulkanContext`.
5.  **Update `CMakeLists.txt`** to include new files.
6.  **Test:** Ensure basic initialization still works.

---

**Phase 2: Window and Surface Management**
*   **Objective:** Isolate GLFW window and Vulkan surface management.
1.  **Create `WindowManager.h` and `WindowManager.cpp`**
    *   [ ] Members: `GLFWwindow* window`, `VkSurfaceKHR surface`.
    *   [ ] Methods:
        *   `WindowManager(const char* title, int width, int height)`
        *   `initWindow()`
        *   `createSurface(VkInstance instance)`
        *   `cleanup(VkInstance instance)` (instance passed for surface destruction)
        *   `getWindow() const`
        *   `getSurface() const`
        *   `shouldClose() const`
        *   `pollEvents()`
        *   `setFramebufferResizedCallback(GLFWframebuffersizefun callback)`
        *   `setWindowUserPointer(void* pointer)`
        *   `getFramebufferSize(int* width, int* height)`
        *   Static callback: `framebufferResizeCallback` (or adapt existing).
2.  **Refactor `VulkanContext`** (if it currently handles surface creation)
    *   [ ] Surface creation/cleanup moves to `WindowManager`. `VulkanContext` might take `VkSurfaceKHR` in constructor or via a setter from `WindowManager`.
3.  **Refactor `VulkanEngine` to use `WindowManager`**
    *   [ ] `VulkanEngine` holds `std::unique_ptr<WindowManager>`.
    *   [ ] Delegate windowing and surface calls.
    *   [ ] Update `framebufferResized` logic.
4.  **Update `CMakeLists.txt`**.
5.  **Test:** Window creation, surface creation, and resize events.

---

**Phase 3: Swapchain Management**
*   **Objective:** Isolate swapchain creation, image views, and recreation logic.
1.  **Create `SwapchainManager.h` and `SwapchainManager.cpp`**
    *   [ ] Members: `VkSwapchainKHR swapChain`, `std::vector<VkImage> swapChainImages`, `VkFormat swapChainImageFormat`, `VkExtent2D swapChainExtent`, `std::vector<VkImageView> swapChainImageViews`.
    *   [ ] Dependencies: `VulkanContext` (for device, physicalDevice), `WindowManager` (for surface, window extent).
    *   [ ] Methods:
        *   `SwapchainManager(VulkanContext* context, WindowManager* windowManager)`
        *   `create()` (was `createSwapChain` + `createImageViews`)
        *   `recreate()`
        *   `cleanup()`
        *   `querySupport(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface) const`
        *   `chooseSurfaceFormat(const std::vector<VkSurfaceFormatKHR>& availableFormats) const`
        *   `choosePresentMode(const std::vector<VkPresentModeKHR>& availablePresentModes) const`
        *   `chooseExtent(const VkSurfaceCapabilitiesKHR& capabilities, GLFWwindow* window) const`
        *   Getters for swapchain details.
2.  **Refactor `VulkanEngine` to use `SwapchainManager`**
    *   [ ] Delegate swapchain related calls.
3.  **Update `CMakeLists.txt`**.
4.  **Test:** Swapchain creation and recreation (e.g., on resize).

---

**Phase 4: Render Pass and Framebuffer Management**
*   **Objective:** Separate render pass and framebuffer setup.
1.  **Create `RenderPassManager.h` and `RenderPassManager.cpp`**
    *   [ ] Members: `VkRenderPass renderPass`.
    *   [ ] Dependencies: `VulkanContext` (for device), `SwapchainManager` (for format).
    *   [ ] Methods: `create(VkFormat swapchainImageFormat, VkFormat depthFormat, VkSampleCountFlagBits msaaSamples)`, `cleanup()`, `get() const`.
2.  **Create `FramebufferManager.h` and `FramebufferManager.cpp`**
    *   [ ] Members: `std::vector<VkFramebuffer> swapChainFramebuffers`.
    *   [ ] Dependencies: `VulkanContext`, `SwapchainManager`, `RenderPassManager`, (and image views for depth/color if MSAA).
    *   [ ] Methods: `create(const std::vector<VkImageView>& swapChainImageViews, VkImageView depthImageView, VkImageView colorImageView, VkExtent2D swapChainExtent, VkRenderPass renderPass)`, `cleanup()`, `get(uint32_t index) const`, `getCount() const`.
3.  **Refactor `VulkanEngine` to use these managers.**
4.  **Update `CMakeLists.txt`**.
5.  **Test:** Render pass and framebuffer creation, especially during swapchain recreation.

---

**Phase 5: Pipeline Management**
*   **Objective:** Isolate graphics and compute pipeline creation.
1.  **Create `DescriptorSetManager.h` and `DescriptorSetManager.cpp`** (Might be part of PipelineManager or separate)
    *   [ ] Members: `VkDescriptorSetLayout descriptorSetLayout`, `VkDescriptorPool descriptorPool`, `std::vector<VkDescriptorSet> descriptorSets`.
    *   [ ] Dependencies: `VulkanContext`.
    *   [ ] Methods: `createLayout()`, `createPool()`, `createSets()`, `cleanupLayout()`, `cleanupPool()`, etc.
2.  **Create `PipelineManager.h` and `PipelineManager.cpp`**
    *   [ ] Members: `VkPipelineLayout graphicsPipelineLayout`, `VkPipeline graphicsPipeline` (and similar for compute).
    *   [ ] Dependencies: `VulkanContext`, `RenderPassManager`, `DescriptorSetManager`.
    *   [ ] Methods: `createGraphicsLayout(VkDescriptorSetLayout descriptorSetLayout)`, `createGraphicsPipeline(VkRenderPass renderPass, VkSampleCountFlagBits msaaSamples, const std::string& vertShaderPath, const std::string& fragShaderPath)`, `createComputePipeline(const std::string& compShaderPath, VkDescriptorSetLayout descriptorSetLayout, VkPipelineLayout& outPipelineLayout, VkPipeline& outPipeline)`, `cleanup()`.
3.  **Refactor `VulkanEngine` to use these managers.**
4.  **Update `CMakeLists.txt`**.
5.  **Test:** Pipeline creation for both graphics and compute.

---

**Phase 6: Command and Synchronization Management**
*   **Objective:** Centralize command pool/buffer and synchronization primitive management.
1.  **Create `CommandManager.h` and `CommandManager.cpp`**
    *   [ ] Members: `VkCommandPool graphicsCommandPool`, `VkCommandPool computeCommandPool`. (Command buffers might be per-frame or per-use, managed where needed or by this manager).
    *   [ ] Dependencies: `VulkanContext`, `DeviceManager` (for queue family indices).
    *   [ ] Methods: `createPools()`, `cleanupPools()`, `createCommandBuffers(VkCommandPool pool, std::vector<VkCommandBuffer>& buffers, uint32_t count)`, `freeCommandBuffers(VkCommandPool pool, std::vector<VkCommandBuffer>& buffers)`, `beginSingleTimeCommands(VkCommandPool pool) const`, `endSingleTimeCommands(VkCommandPool pool, VkCommandBuffer commandBuffer, VkQueue queue) const`.
2.  **Create `SyncManager.h` and `SyncManager.cpp`**
    *   [ ] Members: `std::vector<VkSemaphore> imageAvailableSemaphores`, `renderFinishedSemaphores`, `computeSemaphores`; `std::vector<VkFence> inFlightFences`, `computeFences`. (Potentially `imagesInFlight` if tied to swapchain images directly).
    *   [ ] Dependencies: `VulkanContext`.
    *   [ ] Methods: `createGraphicsSyncObjects(uint32_t count)`, `createComputeSyncObjects(uint32_t count)`, `cleanupGraphicsSyncObjects()`, `cleanupComputeSyncObjects()`. Getters.
3.  **Refactor `VulkanEngine` to use these managers.**
4.  **Update `CMakeLists.txt`**.
5.  **Test:** Command buffer recording, submission, and synchronization.

---

**Phase 7: Resource Management (Buffers, Images, Shaders)**
*   **Objective:** Consolidate creation and management of buffers, images, and shader modules.
1.  **Refine `MemoryPool.h` and `MemoryPool.cpp` (or rename to `ResourceManager`)**
    *   [ ] Current `MemoryPool` from `VulkanEngine.h/.cpp` becomes its own class.
    *   [ ] Add methods for image creation: `createImage()`, `createImageView()`.
    *   [ ] Add methods for shader module management: `loadShaderModule(const std::string& path)`, `destroyShaderModule(VkShaderModule module)`. (Store loaded modules to avoid reloads, or let PipelineManager handle this).
    *   [ ] Manage vertex buffers, uniform buffers, depth/color images.
2.  **Refactor `VulkanEngine` to use the refined `ResourceManager` (or `MemoryPool`).**
3.  **Update `CMakeLists.txt`**.
4.  **Test:** Buffer, image, and shader module lifecycle.

---

**Phase 8: Main Loop and Drawing Logic Review**
*   **Objective:** Ensure `VulkanEngine::run()` and `drawFrame()` correctly coordinate the new manager classes.
1.  [ ] Review `VulkanEngine::run()`: Ensure it correctly calls `WindowManager::pollEvents()` and `drawFrame()`.
2.  [ ] Review `VulkanEngine::drawFrame()`:
    *   [ ] Calls to `SyncManager` for waiting on fences and acquiring semaphores.
    *   [ ] Calls to `SwapchainManager` for acquiring next image.
    *   [ ] Calls to `ResourceManager`/`PipelineManager` for updating uniform buffers.
    *   [ ] Calls to `CommandManager` for command buffer recording.
    *   [ ] Calls to `SyncManager` for queue submission with semaphores/fences.
    *   [ ] Calls to `SwapchainManager` for presentation.
    *   [ ] Handles swapchain recreation logic by coordinating `SwapchainManager`, `RenderPassManager`, `FramebufferManager`, `PipelineManager`.
3.  **Test:** Full application run, including window resizing and an end-to-end rendering/compute cycle.

---

**General Guidelines During Refactoring:**
-   **Commit frequently:** After each logical step or sub-task, commit changes with a clear message.
-   **Build often:** Compile the code frequently to catch errors early.
-   **Test incrementally:** As components are refactored or created, write/update unit tests.
-   **Address TODOs:** Resolve any TODO comments related to the refactoring.
-   **Documentation:** Update comments and Doxygen documentation for new/modified classes and methods.

This is a large undertaking. I will start with **Phase 1: Core Vulkan Context & Device Management**.
I'll create `QueueFamilyIndices.h` first as it's a simple struct.

--- 